#version 460
#extension GL_GOOGLE_include_directive: enable
#include "similar.glsl"

layout (binding = 0, rgba8) uniform image2D colorBuffer;
layout (binding = 1) uniform accelerationStructureEXT topLevelAS;
layout (binding = 2) uniform res {
  vec2 resData;
} resolution;
layout (binding = 4) uniform cameraPosBinding {
  mat3x4 cameraPos;
} camera;
layout (binding = 5) uniform lightsCountBinding {
  uint count;
} lightsCount;

struct LightSourceShader {
	vec3 pos;
	float size;
	vec3 color;
	float unused;
};
layout (binding = 6) buffer lightsBuffer {
  LightSourceShader lights[];
};


layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool shadow;

layout(binding = 3) uniform sampler2D blueNoiseTexture;
vec3 sampleNoise(vec2 coords) {
  return texture(blueNoiseTexture,coords*resolution.resData.xy/vec2(256)).xyz*2-1;
};

vec3 sampleSphere(vec2 coords) {
  return normalize(sampleNoise(coords));
}

float randomValue(inout uint state) {
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state>>28)+4))^state) * 277803737;

    result = (result >> 22) ^ result;
    return result / 4294967295.0;
}



void main() {


    vec2 coords = vec2(0.0, 0.0);
    coords.r = float(gl_LaunchIDEXT.x) / float(gl_LaunchSizeEXT.x);
    coords.g = float(gl_LaunchIDEXT.y) / float(gl_LaunchSizeEXT.y);
    
    vec2 texCoords = (coords-0.5)/resolution.resData.yx*resolution.resData.x;


    //vec3 origin = vec3(-11.4,9.2,4.2);
    vec3 origin = vec3(camera.cameraPos[0].w,camera.cameraPos[1].w,camera.cameraPos[2].w);
    mat3x3 matrix = mat3x3(camera.cameraPos[0].xyz,-camera.cameraPos[1].xyz,camera.cameraPos[2].xyz);
    //vec3 origin = vec3(-4,0,0);

    uvec2 pixelCoord = gl_LaunchIDEXT.xy;
    uint pixelIndex = uint(pixelCoord.y*resolution.resData.x+pixelCoord.x);

    vec3 direction = normalize(vec3(1,-texCoords))*matrix;

    vec3 color = vec3(1.0, 1.0, 1.0);
    vec3 incominglight = vec3(0.0,0.0,0.0);

    // We trace albedo rays
    
    for (int i = 0;i<1;i++) {
      //incominglight = vec3(0.0);
      prd.didHit = true;
      prd.color = vec3(0.0);
      float distanceRay = 10000;
      if (i>0) {
        distanceRay = 10;
      }
      traceRayEXT(topLevelAS, // acceleration structure
          gl_RayFlagsOpaqueEXT,       // rayFlags
          0xFF,           // cullMask
          0,              // sbtRecordOffset
          0,              // sbtRecordStride
          0,              // missIndex
          origin,     // ray origin
          0.001,           // ray min range
          direction,  // ray direction
          distanceRay,           // ray max range
          0               // payload (location = 0)
      );
    if (prd.didHit) {

        float bucketStrength = 0.0;
      
        vec3 directionToSample = vec3(0.0);
        float distanceToSample = 0.0;
        float cosineSample = 0.0;
        vec3 sampleColor = vec3(0.0);
        uint currentSample = 0;

        for (uint light =0;light<lightsCount.count;light++){

        
        vec3 sampleCoords = sampleSphere(coords);
        vec3 spherePos = sampleCoords*-sign(dot(sampleCoords,prd.normal))*lights[light].size+lights[light].pos;
        vec3 directionToSpherePos = normalize(prd.hitPos-spherePos);
        float lenght = sqrt(dot(prd.hitPos-spherePos,prd.hitPos-spherePos));
        float cosine = dot(-directionToSpherePos,prd.normal);
        float outputValue = 2*3.1415926*dot(lights[light].color,vec3(0.299,0.587,0.114))*lights[light].size*lights[light].size*cosine/(lenght*lenght);

        float random = float(randomValue(pixelIndex)*(outputValue+bucketStrength));
        if (random>bucketStrength) {
          currentSample=light+1;
          directionToSample = directionToSpherePos;
          distanceToSample = lenght;
          cosineSample = cosine;
          bucketStrength = outputValue;
          sampleColor = outputValue*lights[light].color; // TODO: Add Weight Estimation
        }
        };


      if (cosineSample>0.0) {
        shadow = false;
        traceRayEXT(topLevelAS, // acceleration structure
          gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,       // rayFlags
          0xFF,           // cullMask
          0,              // sbtRecordOffset
          0,              // sbtRecordStride
          1,              // missIndex
          prd.hitPos,     // ray origin
          0,           // ray min range
          -directionToSample,  // ray direction
          distanceToSample,           // ray max range
          1               // payload (location = 0)
        );
        if (shadow) {
          incominglight+=color*sampleColor;
          color*=1;
        }
        
      }
    }
    incominglight = vec3(prd.color);
    origin = prd.hitPos;
    direction = normalize(prd.normal+sampleSphere(coords));
    }

    
    imageStore(colorBuffer, ivec2(gl_LaunchIDEXT.xy), vec4(incominglight, 0.0));
} 