#version 460
#extension GL_GOOGLE_include_directive: enable
#include "similar.glsl"

layout (binding = 0, rgba8) uniform image2D colorBuffer;
layout (binding = 1) uniform accelerationStructureEXT topLevelAS;
layout (binding = 2) uniform res {
  vec2 resData;
} resolution;
layout (binding = 4) uniform cameraPosBinding {
  mat3x4 cameraPos;
} camera;
layout (binding = 5) uniform lightsCountBinding {
  uint count;
} lightsCount;

struct LightSourceShader {
	vec3 pos;
	float size;
	vec3 color;
	float unused;
};
layout (binding = 6) buffer lightsBuffer {
  LightSourceShader lights[];
};


layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool shadow;

layout(binding = 3) uniform sampler2D blueNoiseTexture;
layout (binding = 9, rgba32f) uniform image2D albedoColorBuffer;
layout (binding = 10, rgba32f) uniform image2D directColorBuffer;
layout (binding = 11, rgba32f) uniform image2D indirectColorBuffer;
layout (binding = 12, rgba32f) uniform image2D normalColorBuffer;
layout (binding = 13, rgba32f) uniform image2D worldPosColorBuffer;
vec3 sampleNoise(vec2 coords) {
  return texture(blueNoiseTexture,coords*resolution.resData.xy/vec2(256)).xyz*2-1;
};

vec3 sampleSphere(vec2 coords) {
  return normalize(sampleNoise(coords));
}

float randomValue(inout uint state) {
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state>>28)+4))^state) * 277803737;

    result = (result >> 22) ^ result;
    return result / 4294967295.0;
}



void main() {


    vec2 coords = vec2(0.0, 0.0);
    coords.r = float(gl_LaunchIDEXT.x) / float(gl_LaunchSizeEXT.x);
    coords.g = float(gl_LaunchIDEXT.y) / float(gl_LaunchSizeEXT.y);
    
    vec2 texCoords = (coords-0.5)/resolution.resData.yx*resolution.resData.x;


    //vec3 origin = vec3(-11.4,9.2,4.2);
    vec3 origin = vec3(camera.cameraPos[0].w,camera.cameraPos[1].w,camera.cameraPos[2].w);
    mat3x3 matrix = mat3x3(camera.cameraPos[0].xyz,-camera.cameraPos[1].xyz,camera.cameraPos[2].xyz);
    //vec3 origin = vec3(-4,0,0);

    uvec2 pixelCoord = gl_LaunchIDEXT.xy;
    uint pixelIndex = uint(pixelCoord.y*resolution.resData.x+pixelCoord.x);

    vec3 direction = normalize(vec3(1,-texCoords))*matrix;

    vec3 color = vec3(1.0, 1.0, 1.0);
    vec3 incominglight = vec3(0.0,0.0,0.0);
    vec3 albedo = vec3(0.0);
    vec3 normal = vec3(0.0);
    vec3 worldPos = vec3(0.0);
    vec3 shadowColor = vec3(0.0);
    // We trace albedo rays
    
    for (int i = 0;i<2;i++) {
      prd.didHit = true;
      prd.color = vec3(0.0);
      float distanceRay = 10000;
      if (i>0) {
        distanceRay = 10;
      }
      traceRayEXT(topLevelAS, // acceleration structure
          gl_RayFlagsOpaqueEXT,       // rayFlags
          0xFF,           // cullMask
          0,              // sbtRecordOffset
          0,              // sbtRecordStride
          0,              // missIndex
          origin,     // ray origin
          0.001,           // ray min range
          direction,  // ray direction
          distanceRay,           // ray max range
          0               // payload (location = 0)
      );
      if (i==0) {
        albedo = prd.color;
        normal = prd.normal*0.5+0.5;
        worldPos = normalize(prd.hitPos-origin)*0.5+0.5;
      }
    if (prd.didHit) {
        
        float bucketStrength = 0.0;
      
        vec3 directionToSample = vec3(0.0);
        float distanceToSample = 0.0;
        float cosineSample = 0.0;
        vec3 sampleColor = vec3(0.0);
        uint currentSample = 0;

        for (uint light =0;light<lightsCount.count;light++){

        
        vec3 sampleCoords = sampleSphere(coords);
        vec3 spherePos = sampleCoords*-sign(dot(sampleCoords,prd.normal))*lights[light].size+lights[light].pos;
        vec3 directionToSpherePos = normalize(prd.hitPos-spherePos);
        float lenght = sqrt(dot(prd.hitPos-spherePos,prd.hitPos-spherePos));
        float cosine = dot(-directionToSpherePos,prd.normal);
        float outputValue = 2*3.1415926*dot(lights[light].color,vec3(0.299,0.587,0.114))*lights[light].size*lights[light].size*cosine/(lenght*lenght);

        float random = float(randomValue(pixelIndex)*(outputValue+bucketStrength));
        if (random>bucketStrength) {
          currentSample=light+1;
          directionToSample = directionToSpherePos;
          distanceToSample = lenght;
          cosineSample = cosine;
          bucketStrength = outputValue;
          sampleColor = lights[light].color; // TODO: Add Weight Estimation
        }
        };


      if (cosineSample>0.0) {
        shadow = false;
        traceRayEXT(topLevelAS, // acceleration structure
          gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,       // rayFlags
          0xFF,           // cullMask
          0,              // sbtRecordOffset
          0,              // sbtRecordStride
          1,              // missIndex
          prd.hitPos,     // ray origin
          0,           // ray min range
          -directionToSample,  // ray direction
          distanceToSample,           // ray max range
          1               // payload (location = 0)
        );
        
        if (shadow) {
          if (i==0) {
            shadowColor=sampleColor*min(bucketStrength,1.0);
          } else {
            incominglight+=prd.color*sampleColor*min(bucketStrength,1.0);
          }
        }
        color*=prd.color;
        
      }
    } else {
      break;
    }
    origin = prd.hitPos;
    direction = normalize(prd.normal+sampleSphere(coords));
    }

    imageStore(albedoColorBuffer,ivec2(gl_LaunchIDEXT.xy),vec4(albedo, 1.0));
    imageStore(directColorBuffer,ivec2(gl_LaunchIDEXT.xy),vec4(shadowColor, 1.0));
    imageStore(indirectColorBuffer,ivec2(gl_LaunchIDEXT.xy),vec4(incominglight, 1.0));
    imageStore(normalColorBuffer,ivec2(gl_LaunchIDEXT),vec4(normal,0.0));
    imageStore(worldPosColorBuffer,ivec2(gl_LaunchIDEXT),vec4(worldPos,0.0));
} 